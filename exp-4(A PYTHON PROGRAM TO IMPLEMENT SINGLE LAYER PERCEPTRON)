import numpy as np

input_value = np.array([[0,0], [0,1], [1,1], [1,0]])
output = np.array([0,0,1,0]).reshape(4,1)

weights = np.array([[0.1], [0.3]])
bias = 0.2

def sigmoid_func(x):
    return 1/(1+np.exp(-x))

def der(x):
    return sigmoid_func(x)*(1 - sigmoid_func(x))

for epochs in range(15000):
    weighted_sum = np.dot(input_value, weights) + bias
    first_output = sigmoid_func(weighted_sum)
    error = first_output - output
    first_der = error
    second_der = der(first_output)
    derivative = first_der * second_der
    t_input = input_value.T
    final_derivative = np.dot(t_input, derivative)
    weights = weights - (0.05 * final_derivative)
    for i in derivative:
        bias = bias - (0.05 * i)

print("Trained Weights:")
print(weights)
print("Trained Bias:")
print(bias)

pred = np.array([1,0])
result = np.dot(pred, weights) + bias
res = sigmoid_func(result)
print(f"\nInput: {pred}, Output: {res[0]}")

pred = np.array([1,1])
result = np.dot(pred, weights) + bias
res = sigmoid_func(result)
print(f"Input: {pred}, Output: {res[0]}")

pred = np.array([0,0])
result = np.dot(pred, weights) + bias
res = sigmoid_func(result)
print(f"Input: {pred}, Output: {res[0]}")

pred = np.array([0,1])
result = np.dot(pred, weights) + bias
res = sigmoid_func(result)
print(f"Input: {pred}, Output: {res[0]}")
